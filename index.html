<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Particle Assistant</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        /* --- UI STYLING --- */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 260px;
            padding: 20px;
            background: rgba(10, 10, 15, 0.75);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            color: #fff;
            z-index: 100;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
        }

        h2 {
            margin: 0 0 5px 0;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .subtitle {
            font-size: 10px;
            color: #888;
            margin-bottom: 20px;
            display: block;
        }

        /* Microphone Button */
        #mic-btn {
            width: 100%;
            padding: 15px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            border-radius: 50px;
            cursor: pointer;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 20px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        #mic-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        #mic-btn.listening {
            background: #ff3333;
            border-color: #ff3333;
            color: white;
            animation: pulse-red 1.5s infinite;
        }

        @keyframes pulse-red {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 51, 51, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(255, 51, 51, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 51, 51, 0);
            }
        }

        /* Transcription Log */
        #chat-log {
            font-size: 12px;
            color: #ccc;
            min-height: 40px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-bottom: 20px;
            font-style: italic;
            border-left: 2px solid #00ffff;
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 20px;
        }

        button.shape-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            color: #aaa;
            border-radius: 6px;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
            font-size: 12px;
        }

        button.shape-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        button.shape-btn.active {
            background: #fff;
            color: #000;
            font-weight: bold;
        }

        .status-container {
            font-size: 10px;
            color: #666;
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #input-video {
            display: none;
        }
    </style>
</head>

<body>
    <div id="ui-panel">
        <h2>A.I. Core</h2>
        <span class="subtitle">System Online ‚Ä¢ Waiting for input</span>

        <button id="mic-btn" onclick="toggleVoice()">
            <span id="mic-icon">üéôÔ∏è</span>
            <span id="mic-text">Activer Vocale</span>
        </button>

        <div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 10px;">
            <input type="text" id="backup-input" placeholder="Tapez ici (ex: coeur rouge)..." 
                   style="width: 70%; padding: 8px; border-radius: 5px; border: none;">
            
            <button onclick="sendManualCommand()" 
                    style="width: 25%; padding: 8px; background: #00ffff; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">
                OK
            </button>
        </div>

        <div style="margin-top: 20px; border: 1px solid #555; padding: 10px; border-radius: 8px;">
            <h3 style="color: yellow; font-size: 12px; margin: 0;">üõ†Ô∏è ZONE R√âPARATION</h3>
            <button onclick="checkAvailableModels()" 
                    style="margin-top:5px; width: 100%; padding: 8px; background: #ffaa00; color: black; border: none; font-weight: bold; cursor: pointer;">
                1. CLIQUER ICI POUR TROUVER LE BON MOD√àLE
            </button>
            <p id="model-result" style="color: #fff; font-size: 11px; margin-top: 5px; word-break: break-all;"></p>
        </div>
        
        <script>
            async function checkAvailableModels() {
                const resultBox = document.getElementById('model-result');
                resultBox.innerText = "Recherche en cours...";
                
                // On utilise ta cl√© d√©finie plus haut
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${GEMINI_API_KEY}`);
                    const data = await response.json();
                    
                    if (data.error) {
                        resultBox.innerText = "ERREUR CL√â : " + data.error.message;
                        return;
                    }
        
                    // On filtre pour trouver les mod√®les qui g√©n√®rent du texte
                    const validModels = data.models
                        .filter(m => m.supportedGenerationMethods.includes("generateContent"))
                        .map(m => m.name.replace("models/", "")); // On garde juste le nom court
        
                    console.log("Mod√®les trouv√©s :", validModels);
                    
                    if (validModels.length > 0) {
                        resultBox.innerHTML = "‚úÖ MOD√àLE TROUV√â : <br><b style='color:#00ff00; font-size:14px'>" + validModels[0] + "</b><br>(C'est celui-l√† qu'il faut utiliser !)";
                        
                        // On met √† jour la variable globale pour le test imm√©diat
                        window.FOUND_MODEL = validModels[0]; 
                        alert("J'ai trouv√© le mod√®le : " + validModels[0] + "\nJe vais tenter de l'utiliser automatiquement.");
                    } else {
                        resultBox.innerText = "Aucun mod√®le compatible trouv√© pour cette cl√©.";
                    }
        
                } catch (e) {
                    resultBox.innerText = "Erreur connexion : " + e.message;
                }
            }
        </script>
        
        <script>
            function sendManualCommand() {
                const text = document.getElementById('backup-input').value;
                if(text) {
                    document.getElementById('chat-log').innerText = `Manuel: "${text}"`;
                    processVoiceCommand(text); // On envoie le texte directement √† l'IA
                    document.getElementById('backup-input').value = ""; // On vide le champ
                }
            }
        </script>

        <div id="chat-log">"Cliquez sur le micro et dites : 'Bonjour' ou 'Forme C≈ìur'..."</div>

        <div class="btn-group">
            <button class="shape-btn active" onclick="manualChangeShape('sphere', this)">üîÆ Sphere (Brain)</button>
            <button class="shape-btn" onclick="manualChangeShape('heart', this)">‚ù§Ô∏è Heart</button>
            <button class="shape-btn" onclick="manualChangeShape('flower', this)">üå∏ Flower</button>
            <button class="shape-btn" onclick="manualChangeShape('saturn', this)">ü™ê Saturn</button>
            <button class="shape-btn" onclick="manualChangeShape('fireworks', this)">üéÜ Fireworks</button>
        </div>

        <div class="status-container">
            <span id="status-text">Camera: Initialize...</span>
        </div>
    </div>

    <video id="input-video"></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- 1. CONFIGURATION ---
        const CONFIG = {
            particleCount: 25000, // Increased for denser "AI Brain" look
            particleSize: 0.05,
            lerpSpeed: 0.06,
            defaultColor: new THREE.Color(0x00ffff)
        };

        let currentShape = 'sphere';
        let isSpeaking = false; // Is the AI currently talking?

        // Interaction State
        const state = {
            tension: 0,
            rotationX: 0, rotationY: 0, rotationZ: 0,
            handsDetected: false
        };

        // --- 2. THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 7;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 3. PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const targetPositions = new Float32Array(CONFIG.particleCount * 3);

        for (let i = 0; i < CONFIG.particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 20;
            targetPositions[i] = positions[i];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const createTexture = () => {
            const cvs = document.createElement('canvas');
            cvs.width = 32; cvs.height = 32;
            const ctx = cvs.getContext('2d');
            // Gradient for soft glow
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.Texture(cvs);
        };
        const tex = createTexture();
        tex.needsUpdate = true;

        const material = new THREE.PointsMaterial({
            size: CONFIG.particleSize,
            color: CONFIG.defaultColor,
            map: tex,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 4. SHAPES ---
        const shapes = {
            sphere: (i) => {
                const phi = Math.acos(-1 + (2 * i) / CONFIG.particleCount);
                const theta = Math.sqrt(CONFIG.particleCount * Math.PI) * phi;
                return {
                    x: 3.0 * Math.cos(theta) * Math.sin(phi),
                    y: 3.0 * Math.sin(theta) * Math.sin(phi),
                    z: 3.0 * Math.cos(phi)
                };
            },
            heart: (i) => {
                const t = (i / CONFIG.particleCount) * Math.PI * 2 * 10;
                const scale = 0.18;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                return { x: x * scale, y: y * scale, z: (Math.random() - 0.5) * 4 };
            },
            flower: (i) => {
                const theta = (i / CONFIG.particleCount) * Math.PI * 2;
                const r = 3 * Math.cos(4 * theta);
                return {
                    x: (r * Math.cos(theta)) + (Math.random() - 0.5) * 0.2,
                    y: (r * Math.sin(theta)) + (Math.random() - 0.5) * 0.2,
                    z: (Math.random() - 0.5) * 2
                };
            },
            saturn: (i) => {
                if (i < CONFIG.particleCount * 0.7) {
                    const p = shapes.sphere(i);
                    return { x: p.x * 0.6, y: p.y * 0.6, z: p.z * 0.6 };
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 3.5 + Math.random() * 2;
                    return { x: r * Math.cos(angle), y: (Math.random() - 0.5) * 0.1, z: r * Math.sin(angle) };
                }
            },
            fireworks: (i) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = Math.random() * 5;
                return {
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                };
            }
        };

        function updateTargets(shapeName) {
            currentShape = shapeName;
            const generator = shapes[shapeName];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const p = generator(i);
                targetPositions[i * 3] = p.x;
                targetPositions[i * 3 + 1] = p.y;
                targetPositions[i * 3 + 2] = p.z;
            }
        }
        updateTargets('sphere');

 // --- 5. AI & VOICE LOGIC (VERSION CONTINUE) ---
 const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const synth = window.speechSynthesis;
        let recognition;
        let autoRestart = false; // Variable pour forcer le red√©marrage

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            
            // ‚ö†Ô∏è C'est ici que √ßa change tout :
            recognition.continuous = true; // Ne s'arr√™te pas apr√®s une phrase
            recognition.interimResults = false;
            recognition.lang = 'fr-FR';

            recognition.onstart = () => {
                console.log("Microphone activ√©");
                document.getElementById('mic-btn').classList.add('listening');
                document.getElementById('mic-text').innerText = "Je vous √©coute en continu...";
            };

            recognition.onend = () => {
                console.log("Microphone coup√©.");
                // Si on n'a pas d√©sactiv√© manuellement, on relance !
                if (autoRestart) {
                    console.log("Relance automatique du micro...");
                    try {
                        recognition.start();
                    } catch(e) {
                        console.log("Le micro est d√©j√† actif.");
                    }
                } else {
                    document.getElementById('mic-btn').classList.remove('listening');
                    document.getElementById('mic-text').innerText = "Activer Vocale";
                }
            };

            recognition.onerror = (event) => {
                console.warn("Erreur reconnaissance vocale :", event.error);
                if (event.error === 'no-speech') {
                    // Ignore l'erreur "pas de parole" et laisse le restart faire le job
                    return; 
                }
            };

            recognition.onresult = (event) => {
                // On prend le dernier r√©sultat (le plus r√©cent)
                const lastResultIndex = event.results.length - 1;
                const text = event.results[lastResultIndex][0].transcript.toLowerCase();
                
                console.log("Entendu :", text);
                document.getElementById('chat-log').innerText = `Vous: "${text}"`;
                
                // On envoie √† l'IA
                processVoiceCommand(text);
            };
        } else {
            document.getElementById('mic-text').innerText = "Non support√©";
            alert("Votre navigateur ne supporte pas la commande vocale (Utilisez Chrome).");
        }

        function toggleVoice() {
            if (!recognition) return;

            if (autoRestart) {
                // Si c'√©tait allum√©, on √©teint tout
                autoRestart = false;
                recognition.stop();
            } else {
                // Si c'√©tait √©teint, on allume le mode continu
                autoRestart = true;
                recognition.start();
            }
        }

        function aiSpeak(text) {
            // Cancel previous speech
            synth.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'fr-FR';
            utterance.pitch = 1;
            utterance.rate = 1.1;

            // Visual Modulation Trigger
            utterance.onstart = () => { isSpeaking = true; };
            utterance.onend = () => { isSpeaking = false; };

            synth.speak(utterance);

            // Log logic
            const log = document.getElementById('chat-log');
            log.innerHTML += `<br><span style="color:#00ffff">IA: "${text}"</span>`;
        }

   

// --- FONCTION IA CORRIG√âE (Mod√®le Stable) ---
const GEMINI_API_KEY = "AIzaSyA4SqhMlm6twDBnPBgbAowovGqY1acH3GY";

// --- FONCTION IA FINALE (Mod√®le Valid√©) ---
// ‚ö†Ô∏è V√©rifie que la variable GEMINI_API_KEY est bien d√©finie plus haut dans ton code avec ta cl√© !

async function askGemini(userText) {
    console.log("Envoi de la demande √† Gemini...", userText);
    
    // ‚úÖ ON UTILISE LE MOD√àLE QUE TU AS TROUV√â
    const modelName = "gemini-2.5-flash"; 
    
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${GEMINI_API_KEY}`;
    
    const prompt = `
    Tu es une IA qui contr√¥le un hologramme 3D.
    Analyse la demande : "${userText}".
    
    R√®gles de r√©ponse :
    1. R√©ponds UNIQUEMENT au format JSON strict (pas de markdown, pas de balises).
    2. Choisis une forme parmi : "sphere", "heart", "flower", "saturn", "fireworks".
    3. Choisis une couleur hexad√©cimale (#RRGGBB).
    4. Ecris une courte phrase dans "speech".
    
    Exemple JSON attendu :
    {"shape": "heart", "color": "#ff0000", "speech": "Je fais appara√Ætre un c≈ìur."}
    `;

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }]
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            alert("ERREUR : " + errorData.error.message);
            return null;
        }

        const data = await response.json();
        
        // S√©curit√© si l'IA est muette
        if (!data.candidates || !data.candidates[0].content) {
            console.warn("R√©ponse vide de l'IA");
            return null;
        }

        const textResponse = data.candidates[0].content.parts[0].text;
        
        // Nettoyage ultime du JSON
        const cleanJson = textResponse.replace(/```json/g, '').replace(/```/g, '').trim();
        
        console.log("Succ√®s ! R√©ponse IA :", cleanJson);
        return JSON.parse(cleanJson);

    } catch (error) {
        console.error("Erreur de traitement :", error);
        // En cas de p√©pin, on affiche une sph√®re rouge pour signaler l'erreur visuellement
        return { shape: "sphere", color: "#ff0000", speech: "Erreur de lecture de ma r√©ponse." };
    }
}

        // Remplacement de ta fonction existante
        async function processVoiceCommand(cmd) {
            document.getElementById('status-text').innerText = "IA : R√©flexion...";

            // Appel √† Gemini
            const aiDecision = await askGemini(cmd);

            if (aiDecision) {
                // 1. Changer la forme
                if (shapes[aiDecision.shape]) {
                    changeShapeUI(aiDecision.shape);
                } else {
                    changeShapeUI('sphere'); // Fallback
                }

                // 2. Changer la couleur
                if (aiDecision.color) {
                    const col = new THREE.Color(aiDecision.color);
                    material.color.set(col);
                }

                // 3. Faire parler l'IA
                if (aiDecision.speech) {
                    aiSpeak(aiDecision.speech);
                }
            } else {
                aiSpeak("D√©sol√©, je n'ai pas pu me connecter √† mon cerveau num√©rique.");
            }

            document.getElementById('status-text').innerText = "IA : Pr√™te";
        }

        // Wrapper to update UI buttons when voice triggers change
        function changeShapeUI(shape) {
            updateTargets(shape);
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            // Find button roughly matching shape name
            const btns = Array.from(document.querySelectorAll('.shape-btn'));
            const match = btns.find(b => b.innerText.toLowerCase().includes(shape));
            if (match) match.classList.add('active');
        }

        window.manualChangeShape = (shape, btn) => {
            updateTargets(shape);
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        };

        // --- 6. MEDIAPIPE HANDS ---
        const videoElement = document.getElementById('input-video');
        const statusText = document.getElementById('status-text');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handsDetected = true;
                statusText.innerText = "Tracking: Active";
                statusText.style.color = "#00ff00";

                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const middleMCP = landmarks[9];

                // Tension (Open/Close)
                const distance = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));
                state.tension = Math.max(0, Math.min(1, (distance - 0.2) * 3));

                // Rotation
                const dx = middleMCP.x - wrist.x;
                const dy = middleMCP.y - wrist.y;
                state.rotationZ = -(Math.atan2(dy, dx) + Math.PI / 2);
                state.rotationY = (wrist.x - 0.5) * 4;
                state.rotationX = (wrist.y - 0.5) * 4;
            } else {
                state.handsDetected = false;
                statusText.innerText = "Tracking: Searching...";
                statusText.style.color = "#ffaa00";

                state.tension += (0.3 - state.tension) * 0.05; // Default idle pulse
            }
        }

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 640, height: 480
        });
        cameraUtils.start();

        // --- 7. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Hand Control Logic
            const targetScale = 0.5 + (state.tension * 2.0);

            if (state.handsDetected) {
                particles.rotation.x += (state.rotationX - particles.rotation.x) * 0.1;
                particles.rotation.y += (state.rotationY - particles.rotation.y) * 0.1;
                particles.rotation.z += (state.rotationZ - particles.rotation.z) * 0.1;
            } else {
                particles.rotation.y += 0.003; // Idle spin
            }

            const pos = geometry.attributes.position.array;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                let tx = targetPositions[ix] * targetScale;
                let ty = targetPositions[iy] * targetScale;
                let tz = targetPositions[iz] * targetScale;

                // --- AI SPEAKING EFFECT ---
                // If AI is speaking, add high frequency noise to simulate voice vibration
                if (isSpeaking) {
                    const frequency = 0.2; // Vibration amplitude
                    const noise = Math.sin(time * 20 + i) * frequency;
                    tx += noise;
                    ty += noise;
                    tz += noise;
                }

                pos[ix] += (tx - pos[ix]) * CONFIG.lerpSpeed;
                pos[iy] += (ty - pos[iy]) * CONFIG.lerpSpeed;
                pos[iz] += (tz - pos[iz]) * CONFIG.lerpSpeed;

                // Idle Jitter
                if (currentShape === 'fireworks') {
                    pos[iy] -= 0.02;
                    if (pos[iy] < -5) pos[iy] = 5;
                } else {
                    pos[ix] += Math.sin(time * 2 + i) * 0.003;
                    pos[iy] += Math.cos(time * 1.5 + i) * 0.003;
                }
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>